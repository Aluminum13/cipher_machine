<html>
	<head>
	<meta charset="UTF-8">
		<script
  src="https://code.jquery.com/jquery-3.6.0.min.js"
  integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
  crossorigin="anonymous"></script>
	</head>
	<body>
	<textarea id="rules" cols="50" rows="50"></textarea>
	<script>


let initStr = '每一格是从1到9的数字\n每一行互不相同\n每一列互不相同\n第[1,2,3,10,11,12,19,20,21]格互不相同\n第[4,5,6,13,14,15,22,23,24]格互不相同\n第[7,8,9,16,17,18,25,26,27]格互不相同\n';
initStr += '第[28,29,30,37,38,39,46,47,48]格互不相同\n第[31,32,33,40,41,42,49,50,51]格互不相同\n第[34,35,36,43,44,45,52,53,54]格互不相同\n';
initStr += '第[55,56,57,64,65,66,73,74,75]格互不相同\n第[58,59,60,67,68,69,76,77,78]格互不相同\n第[61,62,63,70,71,72,79,80,81]格互不相同\n';
initStr += '第1格是5\n第3格是8\n第8格是6\n第11格是4\n第12格是2\n第15格是8\n第18格是3\n第19格是6\n第21格是3\n第23格是4\n第24格是9\n第27格是7\n';
initStr += '第28格是8\n第30格是9\n第32格是3\n第37格是3\n第38格是7\n第40格是2\n第42格是1\n第44格是4\n第45格是8\n第50格是8\n第52格是3\n第54格是2\n';
initStr += '第74格是5\n第64格是1\n';
$('#rules').val(initStr);

console.info('start');
const rulesStr = $('#rules').val().split('\n');

const n = 9;
const m = 9;
const possibleArray = [];
const connectedRules = [];

const getNumber = (str, start) => {
  const number = str.substr(start).match(/^\d+/);
  if (!number) return null;
  return {
    value: parseInt(number[0]),
    stopPos: start + number[0].length,
  };
};

const getNumberList = (str, start) => {
  let index = start + 1;
  const ret = [];
  while (1) {
    const numberToken = getNumber(str, index);
    index = numberToken.stopPos + 1;
    ret.push(numberToken.value - 1);
    if (str[numberToken.stopPos] === ']') {
      return {
        stopPos: numberToken.stopPos + 1,
        set: ret,
      };
    }
  }
};

const getRestrictAreas = (str, start) => {
  const ret = [];
  if (str[0] === '每') {
    if (str.substr(1, 2) === '一行') {
      for (let row = 0; row < n; row++) {
        ret.push([]);
        for (let col = 0; col < m; col++) {
          ret[row].push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: ret,
      };
    } else if (str.substr(1, 2) === '一列') {
      for (let col = 0; col < n; col++) {
        ret.push([]);
        for (let row = 0; row < m; row++) {
          ret[col].push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: ret,
      };
    } else if (str.substr(1, 2) === '一格') {
      for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
          ret.push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: [ret],
      };
    }
  } else if (str[0] === '第') {
    const lineToken = getNumber(str, 1);
    if (lineToken) {
      if (str[lineToken.stopPos] === '行') {
        for (let col = 0; col < m; col++) {
          ret.push((lineToken.value - 1) * m + col);
        }
      } else if (str[lineToken.stopPos] === '列') {
        for (let row = 0; row < n; row++) {
          ret.push(row * m + (lineToken.value - 1));
        }
      } else if (str[lineToken.stopPos] === '格') {
        ret.push(lineToken.value - 1);
      }
    } else if (str[start + 1] === '[') {
      const list = getNumberList(str, start + 1);
      return {
        stopPos: list.stopPos + 1,
        restrictArea: [list.set],
      };
    }
    return {
      stopPos: lineToken.stopPos + 1,
      restrictArea: [ret],
    };
  }
};


const getSet = (str, start) => {
  const numberToken = getNumber(str, start);

  if (numberToken) {
    return [numberToken.value];
  }
  if (str[start] === '从') {
    const firstToken = getNumber(str, start + 1);
    let secondToken;
    if (str[firstToken.stopPos] === '到') {
      secondToken = getNumber(str, firstToken.stopPos + 1);
    }
    const ret = [];
    for (let i = firstToken.value; i <= secondToken.value; i++) {
      ret.push(i);
    }
    return ret;
  }
};

const getRules = (str, start) => {
  if (str[start] === '互') {
    return {
      isDifferent: true,
    };
  } else if (str[start] === '是') {
    return {
      set: getSet(str, start + 1),
    };
  }
};

const globalRules = [];
const parseLine = (lineStr) => {
  if(lineStr === "")return;
  const restrictAreas = getRestrictAreas(lineStr, 0);
  const rules = getRules(lineStr, restrictAreas.stopPos);
  for (let i = 0; i < restrictAreas.restrictArea.length; i++) {
    globalRules.push({
      restrictAreas: restrictAreas.restrictArea[i],
      rules,
    });
  }
};

const relaxRule = (rule, origin) => {
  const getDifference = (setA, setB) => new Set([...setA, ...setB].filter(element => !setB.has(element) || !setA.has(element)));
  if (rule.rules.isDifferent) {
    const fixed = [];
    const areas = rule.restrictAreas;

    const mp = new Map();
    for (let i = 0; i < areas.length; i++) {
	    const possibleList = [...possibleArray[areas[i]]];
      for(let j = 0; j < possibleList.length; j++) {
        const temp = mp.get(possibleList[j]);
        if(temp) {
          mp.set(possibleList[j], temp+1);
        } else {
          mp.set(possibleList[j], 1);
        }
      }
    }
    mp.forEach((val, key)=>{
      if(val === 1) {
        fixed.push(key);
        for (let i = 0; i < areas.length; i++) {
          if (possibleArray[areas[i]].has(key)) {
            origin[areas[i]] = possibleArray[areas[i]];
            possibleArray[areas[i]] = new Set([key]);
          }
        }
      }
    });

    for (let i = 0; i < areas.length; i++) {
      if (possibleArray[areas[i]].size === 1) {
        fixed.push(possibleArray[areas[i]].values().next().value);
      }
    }

    for (let j = 0; j < fixed.length; j++) {
      for (let i = 0; i < areas.length; i++) {
        const possibleList = possibleArray[areas[i]];
        if (possibleList.has(fixed[j]) && possibleList.size > 1) {
          if(!origin[areas[i]]) {
            origin[areas[i]] = possibleList;
          }
          possibleList.delete(fixed[j]);
          if (possibleList.size === 1) {
            fixed.push(possibleList.values().next().value);
          }
        }
      }
    }
  }
};

const relax = () => {
  for (let i = 0; i < globalRules.groupRules.length; i++) {
    const rule = globalRules[globalRules.groupRules[i]];
    relaxRule(rule, []);
  }
};

const mergeSet = (pos, set) => {
  const getIntersection = (setA, setB) => new Set(setB.filter(element => setA.has(element)));
  if (possibleArray[pos] === undefined) {
    possibleArray[pos] = new Set(set);
  } else {
    possibleArray[pos] = getIntersection(possibleArray[pos], set);
  }
};

const getSmallestGrid = () => {
  let smallestGridIndex = -1;
  let smallestGridSize = 128;
  for(let i = 0; i < possibleArray.length; i++) {
    currentSetSize = possibleArray[i].size;
    if(currentSetSize === 1)continue;
    if(currentSetSize < smallestGridSize) {
      smallestGridSize = currentSetSize;
      smallestGridIndex = i;
    }
    if(smallestGridSize === 2) {
      return smallestGridIndex;
    }
  }
  return smallestGridIndex;
}

const resumePossible = (origin) => {
  origin.forEach((set, index) => {
    possibleArray[index] = set;
  });
}

const dfs = () => {
  const smallestGridIndex = getSmallestGrid();
  if(smallestGridIndex === -1) {
    return -1;
  }
  const set = possibleArray[smallestGridIndex];

  for (const item of set.values()) {
    possibleArray[smallestGridIndex] = new Set([item]);
    const origin = [];
    if(connectedRules[smallestGridIndex]){
      for(let i = 0; i < connectedRules[smallestGridIndex].length; i++) {
        relaxRule(globalRules[connectedRules[smallestGridIndex][i]], origin);
      }
    }

    const result = dfs();
    if(result === -1) {
      return result;
    }
    resumePossible(origin);
  }
  possibleArray[smallestGridIndex] = set;

};


const main = () => {
  for (let i = 0; i < rulesStr.length; i++) {
    parseLine(rulesStr[i].replace(/\s/g, ''));
  }
  for (let i = 0; i < n * m; i++) {
    possibleArray.push(undefined);
    connectedRules.push([]);
  }

  globalRules.descriptionRules = [];
  globalRules.groupRules = [];
  for (let i = 0; i < globalRules.length; i++) {
    const rule = globalRules[i];
    const { restrictAreas } = rule;
    const letterSet = rule.rules?.set;
    if (letterSet) {
      globalRules.descriptionRules.push(i);
      for (let j = 0; j < restrictAreas.length; j++) {
        mergeSet(restrictAreas[j], letterSet);
      }
    } else {
      globalRules.groupRules.push(i);
      for (let j = 0; j < restrictAreas.length; j++) {
        connectedRules[restrictAreas[j]].push(i);
      }
    }
  }
  relax();
  dfs();
  console.info("end");
};


main();


	</script>
	</body>
</html>
