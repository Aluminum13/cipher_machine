<html>
	<head>
	<meta charset="UTF-8">
		<script
  src="https://code.jquery.com/jquery-3.6.0.min.js"
  integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
  crossorigin="anonymous"></script>
	</head>
	<body>
  <span>行: </span> <span id="row" contenteditable="true">9</span>
  <span>列: </span> <span id="col" contenteditable="true">9</span>
  <div style="display: flex;">
  	<textarea id="rules" cols="50" rows="50"></textarea>
    <div>
      <div id="sudokuContainer"></div>
      <pre id="sudokuAnswer"></pre>
    </div>
  </div>
  <button id="solveSudoku">solve</button>
  <style>
    .sudoku-grid {
      width: 30px;
      height: 30px;
      border: 1px solid;
      margin-right: -1px;
      margin-bottom: -1px;
    }
    #sudokuContainer {
      margin: 20px;
      display: flex;
      flex-wrap: wrap;
      align-content: flex-start;
    }
    .sudoku-grid-content {
      height: 28px;
      text-align: center;
    }
    .sudoku-index {
      font-size: 12;
      opacity: 0.3;
      position: absolute;
    }
  </style>
	<script>



let initStr = '每一格是从1到9的数字\n每一行互不相同\n每一列互不相同\n第[1,2,3,10,11,12,19,20,21]格互不相同\n第[4,5,6,13,14,15,22,23,24]格互不相同\n第[7,8,9,16,17,18,25,26,27]格互不相同\n';
initStr += '第[28,29,30,37,38,39,46,47,48]格互不相同\n第[31,32,33,40,41,42,49,50,51]格互不相同\n第[34,35,36,43,44,45,52,53,54]格互不相同\n';
initStr += '第[55,56,57,64,65,66,73,74,75]格互不相同\n第[58,59,60,67,68,69,76,77,78]格互不相同\n第[61,62,63,70,71,72,79,80,81]格互不相同\n第1格大于5';
//initStr += '第1格是5\n第3格是8\n第8格是6\n第11格是4\n第12格是2\n第15格是8\n第18格是3\n第19格是6\n第21格是3\n第23格是4\n第24格是9\n第27格是7\n';
//initStr += '第28格是8\n第30格是9\n第32格是3\n第37格是3\n第38格是7\n第40格是2\n第42格是1\n第44格是4\n第45格是8\n第50格是8\n第52格是3\n第54格是2\n';
//initStr += '第74格是5\n第64格是1\n';
$('#rules').val(initStr);

console.info('start');
const rulesStr = $('#rules').val().split('\n');

let n = 9;
let m = 9;
let possibleArray = [];
let connectedRules = [];

const getNumber = (str, start) => {
  const number = str.substr(start).match(/^\d+/);
  if (!number) return null;
  return {
    value: parseInt(number[0]),
    stopPos: start + number[0].length,
  };
};

const getNumberList = (str, start) => {
  let index = start + 1;
  const ret = [];
  while (1) {
    const numberToken = getNumber(str, index);
    index = numberToken.stopPos + 1;
    ret.push(numberToken.value - 1);
    if (str[numberToken.stopPos] === ']') {
      return {
        stopPos: numberToken.stopPos + 1,
        set: ret,
      };
    }
  }
};

const getRestrictAreas = (str, start) => {
  const ret = [];
  if (str[0] === '每') {
    if (str.substr(1, 2) === '一行') {
      for (let row = 0; row < n; row++) {
        ret.push([]);
        for (let col = 0; col < m; col++) {
          ret[row].push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: ret,
      };
    } else if (str.substr(1, 2) === '一列') {
      for (let col = 0; col < n; col++) {
        ret.push([]);
        for (let row = 0; row < m; row++) {
          ret[col].push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: ret,
      };
    } else if (str.substr(1, 2) === '一格') {
      for (let row = 0; row < n; row++) {
        for (let col = 0; col < m; col++) {
          ret.push(row * m + col);
        }
      }
      return {
        stopPos: 3,
        restrictArea: [ret],
      };
    }
  } else if (str[0] === '第') {
    const lineToken = getNumber(str, 1);
    if (lineToken) {
      if (str[lineToken.stopPos] === '行') {
        for (let col = 0; col < m; col++) {
          ret.push((lineToken.value - 1) * m + col);
        }
      } else if (str[lineToken.stopPos] === '列') {
        for (let row = 0; row < n; row++) {
          ret.push(row * m + (lineToken.value - 1));
        }
      } else if (str[lineToken.stopPos] === '格') {
        ret.push(lineToken.value - 1);
      }
    } else if (str[start + 1] === '[') {
      const list = getNumberList(str, start + 1);
      return {
        stopPos: list.stopPos + 1,
        restrictArea: [list.set],
      };
    }
    return {
      stopPos: lineToken.stopPos + 1,
      restrictArea: [ret],
    };
  }
};


const getSet = (str, start) => {
  const numberToken = getNumber(str, start);

  if (numberToken) {
    return [numberToken.value];
  }
  if (str[start] === '从') {
    const firstToken = getNumber(str, start + 1);
    let secondToken;
    if (str[firstToken.stopPos] === '到') {
      secondToken = getNumber(str, firstToken.stopPos + 1);
    }
    const ret = [];
    for (let i = firstToken.value; i <= secondToken.value; i++) {
      ret.push(i);
    }
    return ret;
  }
};

const getRules = (str, start) => {
  if (str[start] === '互') {
    return {
      isDifferent: true,
    };
  } else if (str[start] === '是') {
    return {
      set: getSet(str, start + 1),
    };
  } else if (str[start] === '大') {
    return {
      largerThan: getNumber(str, start + 2).value,
    };
  } else if (str[start] === '大' && str[start+2] === '等') {
    return {
      largerThan: getNumber(str, start + 4).value-1,
    };
  } else if (str[start] === '小') {
    return {
      smallerThan: getNumber(str, start + 2).value,
    };
  } else if (str[start] === '小' && str[start+2] === '等') {
    return {
      smallerThan: getSet(str, start + 4).value+1,
    };
  }
};

let globalRules = [];
let globalFinalRules = [];
const parseLine = (lineStr) => {
  if(lineStr === "")return;
  const restrictAreas = getRestrictAreas(lineStr, 0);
  const rules = getRules(lineStr, restrictAreas.stopPos);
  if(rules.smallerThan || rules.largerThan) {
    for (let i = 0; i < restrictAreas.restrictArea.length; i++) {
      globalFinalRules.push({
        restrictAreas: restrictAreas.restrictArea[i],
        rules,
      });
    }
  } else {
    for (let i = 0; i < restrictAreas.restrictArea.length; i++) {
      globalRules.push({
        restrictAreas: restrictAreas.restrictArea[i],
        rules,
      });
    }
  }
};

const relaxRule = (rule, origin) => {
  const getDifference = (setA, setB) => new Set([...setA, ...setB].filter(element => !setB.has(element) || !setA.has(element)));
  const ruleSet = new Set([]);
  const areas = rule.restrictAreas;
  if (rule.rules.isDifferent) {
    let fixed = [];

    const mp = new Map();

    for (let i = 0; i < areas.length; i++) {
	    const possibleList = [...possibleArray[areas[i]]];
      for(let j = 0; j < possibleList.length; j++) {
        const temp = mp.get(possibleList[j]);
        if(temp) {
          mp.set(possibleList[j], temp+1);
        } else {
          mp.set(possibleList[j], 1);
        }
      }
    }
    mp.forEach((val, key)=>{
      if(val === 1) {
        fixed.push(key);
        for (let i = 0; i < areas.length; i++) {
          if (possibleArray[areas[i]].has(key) && possibleArray[areas[i]].size > 1) {
            if(!origin[areas[i]]) {
              origin[areas[i]] = new Set(possibleArray[areas[i]]);
            }
            possibleArray[areas[i]] = new Set([key]);
            for(const connectedRule of connectedRules[areas[i]]) {
              ruleSet.add(connectedRule);
            }
          }
        }
      }
    });

    for (let i = 0; i < areas.length; i++) {
      if (possibleArray[areas[i]].size === 1) {
        fixed.push(possibleArray[areas[i]].values().next().value);
      }
    }

    for (let j = 0; j < fixed.length; j++) {
      for (let i = 0; i < areas.length; i++) {
        const possibleList = possibleArray[areas[i]];
        if (possibleList.has(fixed[j]) && possibleList.size > 1) {
          if(!origin[areas[i]]) {
            origin[areas[i]] = new Set(possibleList);
          }
          possibleList.delete(fixed[j]);
          if (possibleList.size === 0) {
            console.info("No");
            return -1;
          }
          for(const connectedRule of connectedRules[areas[i]]) {
            ruleSet.add(connectedRule);
          }
          if (possibleList.size === 1) {
            fixed.push(possibleList.values().next().value);
          }
        }
      }
    }
    fixed = [];
    for (let i = 0; i < areas.length; i++) {
      if (possibleArray[areas[i]].size === 1) {
        const number = possibleArray[areas[i]].values().next().value;
        if(fixed.includes(number)) {
          return -1;
        }
        fixed.push(number);
      }
    }
  }

  for(const rules of ruleSet) {
    const result = relaxRule(globalRules[rules], origin);
    if(result === -1)return -1;
  }
  return 1;
};

const relax = () => {
  for (let i = 0; i < globalRules.groupRules.length; i++) {
    const rule = globalRules[globalRules.groupRules[i]];
    relaxRule(rule, [], i);
  }
};

const mergeSet = (pos, set) => {
  const getIntersection = (setA, setB) => new Set(setB.filter(element => setA.has(element)));
  if (possibleArray[pos] === undefined) {
    possibleArray[pos] = new Set(set);
  } else {
    possibleArray[pos] = getIntersection(possibleArray[pos], set);
  }
};

const getSmallestGrid = () => {
  let smallestGridIndex = -1;
  let smallestGridSize = 128;
  for(let i = 0; i < possibleArray.length; i++) {
    currentSetSize = possibleArray[i].size;
    if(currentSetSize === 1)continue;
    if(currentSetSize < smallestGridSize) {
      smallestGridSize = currentSetSize;
      smallestGridIndex = i;
    }
    if(smallestGridSize === 2) {
      return smallestGridIndex;
    }
  }
  return smallestGridIndex;
}

const resumePossible = (origin) => {
  origin.forEach((set, index) => {
    possibleArray[index] = set;
  });
}

const dfs = () => {
  const smallestGridIndex = getSmallestGrid();
  if(smallestGridIndex === -1) {
    const result = [];
    let answer = "";
    let temp = [];
    for(let i = 0; i < possibleArray.length; i++) {
      const number = possibleArray[i].values().next().value;
      temp.push(number);
      answer += number + ' ';
      if(i % m === m-1) {
        result.push(temp);
        answer += '\n';
        temp = [];
      }
    }
    console.info(result);
    console.info(answer);
    $('#sudokuAnswer').html(answer);
    return -1;
  }
  const set = possibleArray[smallestGridIndex];

  for (const item of set.values()) {
    const origin = [];
    origin[smallestGridIndex] = new Set(possibleArray[smallestGridIndex]);
    possibleArray[smallestGridIndex] = new Set([item]);
    if(connectedRules[smallestGridIndex]){
      for(let i = 0; i < connectedRules[smallestGridIndex].length; i++) {
        const result = relaxRule(globalRules[connectedRules[smallestGridIndex][i]], origin, connectedRules[smallestGridIndex][i]);
        if(result === -1) {
          resumePossible(origin);
          return -2;
        }
      }
    }

    const result = dfs();
    if(result === -1) {
      return result;
    }
    resumePossible(origin);
  }
  possibleArray[smallestGridIndex] = set;

};
const largerSet = (list, num) => {
  const ret = new Set([]);
  for(const x of list) {
    if(x > num) {
      ret.add(x);
    }
  }
  return ret;
}

const smallSet = (list, num) => {
  const ret = new Set([]);
  for(const x of list) {
    if(x < num) {
      ret.add(x);
    }
  }
  return ret;
}

const solve = (rulesStr) => {
  possibleArray = [];
  connectedRules = [];
  globalRules = [];
  globalFinalRules = [];
  for (let i = 0; i < rulesStr.length; i++) {
    parseLine(rulesStr[i].replace(/\s/g, ''));
  }
  for (let i = 0; i < n * m; i++) {
    possibleArray.push(undefined);
    connectedRules.push([]);
  }

  globalRules.descriptionRules = [];
  globalRules.groupRules = [];
  for (let i = 0; i < globalRules.length; i++) {
    const rule = globalRules[i];
    const { restrictAreas } = rule;
    const letterSet = rule.rules?.set;
    if (letterSet) {
      globalRules.descriptionRules.push(i);
      for (let j = 0; j < restrictAreas.length; j++) {
        mergeSet(restrictAreas[j], letterSet);
      }
    } else {
      globalRules.groupRules.push(i);
      for (let j = 0; j < restrictAreas.length; j++) {
        connectedRules[restrictAreas[j]].push(i);
      }
    }
  }

  for (let i = 0; i < globalFinalRules.length; i++) {
    const rule = globalFinalRules[i];
    const { restrictAreas } = rule;
    if (rule.rules?.largerThan) {
      for (let j = 0; j < restrictAreas.length; j++) {
        possibleArray[restrictAreas[j]] = largerSet(possibleArray[restrictAreas[j]], rule.rules.largerThan);
      }
    } else if(rule.rules?.smallerThan) {
      for (let j = 0; j < restrictAreas.length; j++) {
        possibleArray[restrictAreas[j]] = smallSet(possibleArray[restrictAreas[j]], rule.rules.largerThan);
      }
    }
  }
  relax();
  dfs();
  console.info("end");
};

const generate = (n, m) => {
  $('#sudokuContainer').innerHTML = "";
  $('#sudokuContainer').width(m*30 + m);
  $('#sudokuContainer').height(n*30 + n);
  for(let i = 0; i < n*m; i++) {
    $('#sudokuContainer').append(`<div class="sudoku-grid"><div class="sudoku-index">${i+1}</div><div id="${i}" class="sudoku-grid-content" contenteditable="true"></div></div>`);
  }
  $('.sudoku-grid-content').on('focus', function() {
    before = $(this).html();
  }).on('blur keyup paste', function() { 
    if (before != $(this).html()) { before = $(this).html(); $(this).trigger('change'); }
  });

  $('.sudoku-grid-content').on('change', (e) =>{
    console.info(e.target.innerText);
    const text = e.target.innerText;
    const number = parseInt(e.currentTarget.id);
    console.info(number);
    const rulesStr = $('#rules').val().split('\n');
    let content = "";
    for(let i = 0; i < rulesStr.length; i++) {
      rulesWithoutSpace = rulesStr[i].replace(/\s/g, '');
      if(rulesWithoutSpace.includes(`第${number+1}格是`)) {
        continue;
      }
      content += `${rulesWithoutSpace}\n`;
    }
    if(text != '') {
      content += `第${number+1}格是${text}\n`;
    }
    $('#rules').val(content);
  });

}
generate(n, m);

$('#solveSudoku').click(() => {
  solve($('#rules').val().split('\n'));
})

	</script>
	</body>
</html>
