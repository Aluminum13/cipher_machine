<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>rubik cube</title>
		<link rel="stylesheet" href="./bootstrap.min.css">
		<script src="./jquery.min.js"></script>
		<script src="./bootstrap.min.js"></script>
		<style>
			.face-container {
				height: 100px;
				width: 100px;
				background-color: red;
			}
		</style>
	</head>
	<body>
		<canvas id="rubik-cube" height="300px" width="300px"></canvas>
		<button onclick="rubicCubeStage.front(1)">front</button>
		<button onclick="rubicCubeStage.up(1)">up</button>
		<button onclick="rubicCubeStage.back(1)">back</button>
		<button onclick="rubicCubeStage.bottom(1)">bottom</button>
		<button onclick="rubicCubeStage.left(1)">left</button>
		<button onclick="rubicCubeStage.right(1)">right</button>
		<div id="expand">
		</div>
		<script>
class Point3D {
	constructor(x, y, z) {
		this.angleX = 0;
		this.angleY = 0;
		this.angleZ = 0;
		this.originX = x;
		this.originY = y;
		this.originZ = z;
		this.x = x;
		this.y = y;
		this.z = z;
		this.mat = [[1,0,0],[0,1,0],[0,0,1]];
	}
	multiply(mat1, mat2) {
		const ret = [[0,0,0],[0,0,0],[0,0,0]];
		for(let i = 0; i < 3; i++) {
			for(let j = 0; j < 3; j++) {
				for(let k = 0; k < 3; k++) {
					ret[i][j] += mat1[i][k]*mat2[k][j];
				}
			}
		}
		return ret;
	}

	rotateHelp(angleRad, axis) {
		let newX = this.originX, newY = this.originY, newZ = this.originZ;
		switch (axis)
		{
			case "x":
			{
			newY = this.originY * Math.cos(angleRad) - this.originZ * Math.sin(angleRad);
			newZ = this.originY * Math.sin(angleRad) + this.originZ * Math.cos(angleRad);
			break;
			} 
			case "y":
			{
			newX = this.originX * Math.cos(angleRad) + this.originZ * Math.sin(angleRad);
			newZ = -this.originX * Math.sin(angleRad) + this.originZ * Math.cos(angleRad);
			break;
			} 
			case "z":
			{
			newX = this.originX * Math.cos(angleRad) - this.originY * Math.sin(angleRad);
			newY = this.originX * Math.sin(angleRad) + this.originY * Math.cos(angleRad);
			break;
			}
		}
		this.originX = newX;
		this.originY = newY;
		this.originZ = newZ;

	}
	rotate(angle, axis, op) {
		const mat = [[1,0,0],[0,1,0],[0,0,1]];
		const angleRad = angle * Math.PI / 180;
		if(op === true) { 
			this.rotateHelp(angleRad, axis);
		}
		else 
		switch (axis)
		{
			case "x":
			{
			mat[1][1] = Math.cos(angleRad);
			mat[1][2] = -Math.sin(angleRad);
			mat[2][1] = Math.sin(angleRad);
			mat[2][2] = Math.cos(angleRad);
			this.angleX += angle;
			break;
			} 
			case "y":
			{
			mat[0][0] = Math.cos(angleRad);
			mat[2][0] = -Math.sin(angleRad);
			mat[0][2] = Math.sin(angleRad);
			mat[2][2] = Math.cos(angleRad);
			this.angleY += angle;
			break;
			} 
			case "z":
			{
			mat[0][0] = Math.cos(angleRad);
			mat[0][1] = -Math.sin(angleRad);
			mat[1][0] = Math.sin(angleRad);
			mat[1][1] = Math.cos(angleRad);
			this.angleZ += angle;
			break;
			}
		}
		this.mat = this.multiply(this.mat, mat);
		const xx = this.originX * this.mat[0][0] + this.originY * this.mat[0][1]+ this.originZ * this.mat[0][2];
		const yy = this.originX * this.mat[1][0] + this.originY * this.mat[1][1]+ this.originZ * this.mat[1][2];
		const zz = this.originX * this.mat[2][0] + this.originY * this.mat[2][1]+ this.originZ * this.mat[2][2];
		this.x = xx;
		this.y = yy;
		this.z = zz;
	}
}

class Rectangle {
	constructor(a, b, c, d, len, color) {
		this.points = [a,b,c,d];
		this.len = len;
		if(!color) {
			color = "red";
		}
		this.color = color;
	}
	getRandomColor() {
		return "rgb(" + Math.round(Math.random() * 255) + "," + Math.round(Math.random() * 255) + ',' + Math.round(Math.random() * 10) + ')';
	}
	render(ctx, index) {
		const v1 = new Point3D(this.points[1].x - this.points[0].x, this.points[1].y - this.points[0].y, this.points[1].z - this.points[0].z);
		const v2 = new Point3D(this.points[3].x - this.points[0].x, this.points[3].y - this.points[0].y, this.points[3].z - this.points[0].z);
		var normalP3D = new Point3D(v1.y*v2.z-v2.y*v1.z, v1.z*v2.x-v2.z*v1.x, v1.x*v2.y-v2.x*v1.y);
		if(normalP3D.x <= 0) {
			return;

		} 

		const p1 = new Point3D(this.points[0].y+100, this.points[0].z+100);
		const p2 = new Point3D(this.points[1].y+100, this.points[1].z+100);
		const p3 = new Point3D(this.points[2].y+100, this.points[2].z+100);
		const p4 = new Point3D(this.points[3].y+100, this.points[3].z+100);
		ctx.beginPath();
		ctx.moveTo(this.points[0].y+100, this.points[0].z+100);
		ctx.lineTo(this.points[1].y+100, this.points[1].z+100);
		ctx.lineTo(this.points[2].y+100, this.points[2].z+100);
		ctx.lineTo(this.points[3].y+100, this.points[3].z+100);
		ctx.lineTo(this.points[0].y+100, this.points[0].z+100);
		ctx.stroke();
		let u = Math.sqrt((p1.x-p4.x)*(p1.x-p4.x)+(p1.y-p4.y)*(p1.y-p4.y))/this.len;
		u = (p1.y-p4.y)/this.len;
		let v = (p2.x-p1.x)/this.len;
		let uu = (p2.y-p1.y)/(p2.x-p1.x);
		let vv = (p4.x-p1.x)/(p4.y-p1.y);
		if(Math.abs(p4.y-p1.y) < 0.0000001) {
			vv = 0;
		}
		ctx.setTransform(v,uu*v,vv*u,u,this.points[3].y+100,this.points[3].z+100);
		ctx.fillStyle=this.color;
		/*
		var img=document.getElementById("scream");
		ctx.drawImage(img,0,0, this.len,this.len);
		*/
		ctx.fillRect(0,0,this.len,this.len);
		ctx.fillStyle="black";
		ctx.fillText (index.toString(), 7,7);

		ctx.setTransform(1,0,0,1,0,0);

		//ctx.fillRect(0,0,this.len,this.len);
	}

}

class Cube {
	constructor(position, len, colors, index) {
		this.index = index;
		if(!colors) {
			colors = [];
		}
		const points = [];
		for(let i = 0; i < 8; i++) {
			points.push(new Point3D(
				position.x + ((i)&1)*len, 
				position.y + ((i>>1)&1)*len, 
				position.z + ((i>>2)&1)*len, 
			));
		}
		//up, back, bottom, front, "right", left
		//white, orange, yellow, red, blue, green
		const faceIndex = [[2,0,1,3],[5,7,3,1],[4,6,7,5],[6,4,0,2],[7,6,2,3],[4,5,1,0]];
		this.faces = [];
		const faceIndexCount = faceIndex.length;
		const isPointUsed = [];
		for(let i = 0; i < faceIndexCount; i++) {
			if(colors[i] === null) {
				continue;
			}
			isPointUsed[faceIndex[i][0]] = true;
			isPointUsed[faceIndex[i][1]] = true;
			isPointUsed[faceIndex[i][2]] = true;
			isPointUsed[faceIndex[i][3]] = true;
			const face = new Rectangle(
				points[faceIndex[i][0]],
				points[faceIndex[i][1]],
				points[faceIndex[i][2]],
				points[faceIndex[i][3]],
				len,
				colors[i]
			);
			this.faces.push(face);
		}
		this.points = [];
		for(let i = 0; i < 8; i++) {
			if(isPointUsed[i] === true) {
				this.points.push(points[i]);
			}

		}
	}
	render(ctx) {
		for(let face of this.faces) {
			face.render(ctx, this.index);
		}
	}
	rotate(angle, axis, op) {
		for(let point of this.points) {
			point.rotate(angle, axis, op);
		}
	}
}

class Scene {
	constructor(ctx) {
		this.objList = [];
		this.ctx = ctx;
	}
	add(obj) {
		this.objList.push(obj);
	}
	render() {
		for(let obj of this.objList) {
			obj.render(this.ctx);
		}
	}
}

class RubikCube {
	ontheEdge(index) {
		if(index===0)return true;
		if(index===this.degree-1)return true;
		return false;
	}
	constructor(position, len, degree) {
		if(!degree) {
			degree = 3;
		}
		this.degree = degree;
		this.blockSize = len / degree;
		this.cubes = [];
		const defaultColor = ["white", "orange", "yellow", "red", "blue", "green"];
		let index = 0;
		for(let i = 0; i < degree; i++) {
			for(let j = 0; j < degree; j++) {
				for(let k = 0; k < degree; k++) {
					if(!this.ontheEdge(i) && !this.ontheEdge(j) && !this.ontheEdge(k)) {
						continue;
					}
					const pos = new Point3D(position.x+i*this.blockSize, position.y+j*this.blockSize,position.z+k*this.blockSize);
					const colors = defaultColor.slice(0);
					if(k != 0) colors[0] = null;
					if(k != degree-1) colors[2] = null;
					if(i != degree-1) colors[1] = null;
					if(i != 0) colors[3] = null;
					if(j != degree-1) colors[4] = null;
					if(j != 0) colors[5] = null;
					//if(i != degree-1) colors[2] = null;
					const cube = new Cube(pos, this.blockSize, colors, index++);
					this.cubes.push(cube);
				}
			}
		}

	}
	render(ctx) {
		const cubes = this.cubes.slice(0);
		cubes.sort((a,b)=>b.points[0].x - a.points[0].x);
		for(let cube of cubes) {
			cube.render(ctx);
		}
	}
	rotate(angle, axis) {
		for(let cube of this.cubes) {
			cube.rotate(angle, axis);
		}
	}
	front(inverse) {
		this.cubes[0].rotate(90*inverse, "x", true);
		this.cubes[1].rotate(90*inverse, "x", true);
		this.cubes[2].rotate(90*inverse, "x", true);
		this.cubes[3].rotate(90*inverse, "x", true);
		this.cubes[4].rotate(90*inverse, "x", true);
		this.cubes[5].rotate(90*inverse, "x", true);
		this.cubes[6].rotate(90*inverse, "x", true);
		this.cubes[7].rotate(90*inverse, "x", true);
		this.cubes[8].rotate(90*inverse, "x", true);
	}
	up(inverse) {
		this.cubes[0].rotate(90*inverse, "z", true);
		this.cubes[3].rotate(90*inverse, "z", true);
		this.cubes[6].rotate(90*inverse, "z", true);
		this.cubes[9].rotate(90*inverse, "z", true);
		this.cubes[12].rotate(90*inverse, "z", true);
		this.cubes[14].rotate(90*inverse, "z", true);
		this.cubes[17].rotate(90*inverse, "z", true);
		this.cubes[20].rotate(90*inverse, "z", true);
		this.cubes[23].rotate(90*inverse, "z", true);
	}
	back(inverse) {
		this.cubes[17].rotate(90*inverse, "x", true);
		this.cubes[18].rotate(90*inverse, "x", true);
		this.cubes[19].rotate(90*inverse, "x", true);
		this.cubes[20].rotate(90*inverse, "x", true);
		this.cubes[21].rotate(90*inverse, "x", true);
		this.cubes[22].rotate(90*inverse, "x", true);
		this.cubes[23].rotate(90*inverse, "x", true);
		this.cubes[24].rotate(90*inverse, "x", true);
		this.cubes[25].rotate(90*inverse, "x", true);
	}

}


let rotationAngle = {x: 10,y:10, z:10};
class RubikCubeStage {
	constructor() {
		this.rotationAngle = {x: 10,y:10, z:10};
		const len = 90;
		this.cube = new RubikCube(new Point3D(-len/2,-len/2,-len/2), len);
		this.rotate(this.rotationAngle);
		this.draw(this.rotationAngle);
	}
	rotate(rotationAngle) {
		this.rotationAngle = rotationAngle;
		const cube = this.cube;
		cube.rotate(rotationAngle.x, 'x');
		cube.rotate(rotationAngle.y, 'y');
		cube.rotate(rotationAngle.z, 'z');
	}
	draw(rotationAngle) {
		const cube = this.cube;

		var canvas = document.getElementById('rubik-cube'),
		ctx = canvas.getContext('2d');

		ctx.clearRect(0,0,canvas.width,canvas.height); 

		const scene = new Scene(ctx);
		scene.add(cube);
		scene.render();
	}
	front(inverse) {
		if(!inverse)inverse = 1;
		this.cube.front(inverse);
		this.draw();
	}
	up(inverse) {
		if(!inverse)inverse = 1;
		this.cube.up(inverse);
		this.draw();
	}
	back(inverse) {
		if(!inverse)inverse = 1;
		this.cube.back(inverse);
		this.draw();
	}
}

const rubicCubeStage = new RubikCubeStage();
init = () => {
	for(let i = 0; i < 4; i++) {
		$('#expand').append(`<div id="expand-${i}" class="face-container"></div>`);
	}
	$('#expand-0').append(`<div id="face-${1}" class="face"></div>`);
	$('#expand-1').append(`<div id="face-${2}" class="face"></div>`);
	$('#expand-1').append(`<div id="face-${3}" class="face"></div>`);
	$('#expand-1').append(`<div id="face-${4}" class="face"></div>`);
	$('#expand-2').append(`<div id="face-${5}" class="face"></div>`);
	$('#expand-3').append(`<div id="face-${6}" class="face"></div>`);
}
init();

let ppMousePressed = false;
let originCoordinate = {};
$('#rubik-cube').mousedown((e) => {
    if(e.which === 1) // left click
    {
        var mouseX = e.pageX;
        var mouseY = e.pageY;
		if(ppMousePressed === false) {
			originCoordinate.x = mouseX;
			originCoordinate.y = mouseY;
		}
        ppMousePressed = true;
    }
});

$('#rubik-cube').mouseup((e) => {
    ppMousePressed = false;
});

$('#rubik-cube').mousemove((e) => {
    if(ppMousePressed === true)
    {
		let mouseX = e.pageX;
        let mouseY = e.pageY;
		let diffX = (mouseX - originCoordinate.x) / 2;
		let diffY = (mouseY - originCoordinate.y) / 2;
		if(diffX < 1 && diffY < 1)return;
		rotationAngle.y -= diffX;
		rotationAngle.y += diffY;
		rubicCubeStage.rotate(rotationAngle);
		rubicCubeStage.draw();
		console.info(diffX);
		originCoordinate.x = mouseX;
		originCoordinate.y = mouseY;
    }
});

$('#rubik-cube').on("touchstart", function(e) {
	var mouseX = e.originalEvent.changedTouches[0].pageX;
	var mouseY = e.originalEvent.changedTouches[0].pageY;
	if(ppMousePressed === false) {
		originCoordinate.x = mouseX;
		originCoordinate.y = mouseY;
	}
	ppMousePressed = true;

});

$('#rubik-cube').on("touchend", function(e) {
	ppMousePressed = false;
});
$('#rubik-cube').on("touchmove", function(e) {
	if(ppMousePressed === true)
    {
		var mouseX = e.originalEvent.changedTouches[0].pageX;
		var mouseY = e.originalEvent.changedTouches[0].pageY;
		let diffX = (mouseX - originCoordinate.x) / 20;
		let diffY = (mouseY - originCoordinate.y) / 20;
		if(diffX < 1 && diffY < 1)return;
		rotationAngle.z -= diffX;
		rotationAngle.y -= diffY;
		rubicCubeStage.rotate(rotationAngle);
		rubicCubeStage.draw();
		console.info(diffX);
		originCoordinate.x = mouseX;
		originCoordinate.y = mouseY;
    }
});

	
		</script>
	</body>
</html>
